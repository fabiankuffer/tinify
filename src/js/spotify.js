//calls the spotify-api to get the user-id from spotify
//returns a promise
function getSpotifyUserID(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200) {
                    let response = JSON.parse(xhttp.responseText); 
                    spotify_UserID = response.id;
                    resolve();
                } else {
                    reject();
                }
            }
        };
        xhttp.open("get", "https://api.spotify.com/v1/me", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send();
    });
}


//calls the spotify-api to check the user playlists if there is one called tinify
//returns a promise
function checkPlaylist(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200) {
                    let response = JSON.parse(xhttp.responseText); 
                    for(let i = 0; i < response.items.length; i++){
                        if(response.items[i].name == "Tinify"){
                            //adds the playlistid to an local var
                            spotify_PlaylistID = response.items[i].id;
                            break;
                        }
                    }
                    if(spotify_PlaylistID != null){
                        resolve();
                    } else {
                        reject();
                    }
                } else {
                    reject();
                }
            }
        };
        xhttp.open("get", "https://api.spotify.com/v1/me/playlists", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send();
    });
}

//calls the spotify-api to create a new playlist called tinify
//returns a promise
function createPlaylist(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200 || this.status == 201) {
                    let response = JSON.parse(xhttp.responseText); 
                    spotify_PlaylistID = response.id;
                    resolve();
                } else {
                    reject();
                }
            }
        };
        xhttp.open("post", "https://api.spotify.com/v1/users/"+spotify_UserID+"/playlists", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send(JSON.stringify({ "name": "Tinify", "description": "Autogenerated Playlist from Tinify", "public": false}));
    });
}

//function to load a new song depends on the user preference for music recommendation
function loadSong(){
    if(recommendation == 0){
        return randomSong();
    } else {
        return recommendedSong();
    }
}

//calls the spotify-api to get an list of toptracks of the user
//is necessary to get an recommended song from spotify
//if it resolves the resolve function is called with the toptracks
//returns a promise
function getTopTracks(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200) {
                    let response = JSON.parse(xhttp.responseText); 
                    if(response.hasOwnProperty("items")){
                        if(response.items.length > 0){
                            resolve({"items":response.items});
                        } else {
                            reject();
                        }
                    } else {
                        reject();
                    }
                } else {
                    reject();
                }
            }
        };
        xhttp.open("get", "https://api.spotify.com/v1/me/top/tracks?limit=10", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send();
    });
}

//calls the spotify-api to get an list of topartists of the user
//is necessary to get an recommended song from spotify
//if it resolves the resolve function is called with the topartists
//returns a promise
function getTopArtists(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200) {
                    let response = JSON.parse(xhttp.responseText); 
                    if(response.hasOwnProperty("items")){
                        if(response.items.length > 0){
                            resolve({"items":response.items});
                        } else {
                            reject();
                        }
                    } else {
                        reject();
                    }
                } else {
                    reject();
                }
            }
        };
        xhttp.open("get", "https://api.spotify.com/v1/me/top/artists?time_range=medium_term&limit=10", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send();
    });
}

//calls the spotify-api to get an recommended song
//is the last step to get a recommended song from spotify
//if it resolves the resolve function is called with the informations of a song
//if it rejects the reject function is called with the options to display a default message
//return is a promise
function recommendedSong(){
    return new Promise(function(resolve,reject){
        //checks for toptracks
        getTopTracks().then(
            function(dataTracks){
                //seedtrack from a random track for the recommended song call
                let seedtrack = dataTracks.items[Math.floor(Math.random() * dataTracks.items.length)].id;
                //checks for topartists
                getTopArtists().then(
                    function(dataArtists){
                        //seedartist from a random artist for the recommended song call
                        let seedArtist = dataArtists.items[Math.floor(Math.random() * dataArtists.items.length)].id;
                        //create genre string for the recommended song call
                        let genres = "";
                        for(let i = 0; i < 3; i++){
                            let genreArray = dataArtists.items[Math.floor(Math.random() * dataArtists.items.length)].genres;
                            if(genreArray.length > 0){
                                genres = genres + genreArray[Math.floor(Math.random() * genreArray.length)];
                                if(i != 2){
                                    genres = genres + ",";
                                }
                            }
                        }
                        genres = encodeURI(genres);

                        //call for a recommended song
                        let xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                            if (this.readyState == 4){
                                if(this.status == 200) {
                                    let response = JSON.parse(xhttp.responseText); 
                                    resolve({"id":response.tracks[0].id,"name":response.tracks[0].name,"preview_url":response.tracks[0].preview_url, "artists": response.tracks[0].artists, "cover":response.tracks[0].album.images[0].url});
                                } else {
                                    reject({"displayError":true});
                                }
                            }
                        };
                        xhttp.open("get", "https://api.spotify.com/v1/recommendations?limit=25&seed_artists="+encodeURI(seedArtist)+"&seed_genres="+genres+"&seed_tracks="+encodeURI(seedtrack), true);
                        xhttp.setRequestHeader("Accept","application/json");
                        xhttp.setRequestHeader("Content-Type","application/json");
                        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
                        xhttp.send();
                    },
                    //error messages for the user
                    function(){
                        displayInSnackbar("Spotify does not yet have enough information about your song taste");
                        reject({"displayError":false});
                    }
                );
            },
            function(){
                displayInSnackbar("Spotify does not yet have enough information about your song taste");
                reject({"displayError":false});
            }
        );
    });
}

//calls the spotify-api to get a random song
//if it resolves the resolve function is called with the informations of a song
//if it rejects the reject function is called with the options to display a default message
//return is a promise
function randomSong(){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200) {
                    let response = JSON.parse(xhttp.responseText); 
                    resolve({"id":response.tracks.items[0].id,"name":response.tracks.items[0].name,"preview_url":response.tracks.items[0].preview_url, "artists": response.tracks.items[0].artists, "cover":response.tracks.items[0].album.images[0].url});
                } else {
                    reject({"displayError":true});
                }
            }
        };
        //random offset from the search sesults
        const randomOffset = Math.floor(Math.random() * 1000);
        xhttp.open("get", "https://api.spotify.com/v1/search?type=track&limit=1&offset="+randomOffset+"&q="+getRandomSearch(), true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send();
    });
}

//calls the spotify-api to add a song to the playlist tinify
//returns a promise
function addSongToPlaylist(song_id, playlist_id){
    return new Promise(function(resolve, reject){
        let xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4){
                if(this.status == 200 || this.status == 201) {
                    resolve();
                } else {
                    reject();
                }
            }
        };
        xhttp.open("post", "https://api.spotify.com/v1/playlists/"+playlist_id+"/tracks", true);
        xhttp.setRequestHeader("Accept","application/json");
        xhttp.setRequestHeader("Content-Type","application/json");
        xhttp.setRequestHeader("Authorization","Bearer "+localStorage.getItem("accesstoken"));
        xhttp.send(JSON.stringify({"uris": ["spotify:track:"+song_id]}));
    });
}

//this functions tries 100 times if there is a song from spotify that wasn't reviewed by the user and has a preview url
async function getValidSong(count = 0) {
    if(count < 100){
        //call this function to get a new accesstoken if the current one is to old
        await checkAccessToken().finally(
            async function(){
                await loadSong().then(
                    function(data){
                        if(data.preview_url == null){
                            //recursive call this function for a new song if there was no preview url
                            getValidSong(count+1);
                        } else {
                            checkReviewed(data.id).then(
                                function(){
                                    //if there was an succes display the new song
                                    displaySong(data);
                                },
                                function(){
                                    //recursive call this function for a new song if there was no preview url
                                    getValidSong(count+1);
                                }
                            );
                        }
                    },
                    function(data){
                        if(data.displayError){
                            displayInSnackbar("Spotify error");
                        }
                    }
                );
            }
        );
    } else {
        displayInSnackbar("100 songs searched no new found");
    }
}